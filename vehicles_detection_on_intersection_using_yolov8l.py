# -*- coding: utf-8 -*-
"""Vehicles Detection On Intersection Using YOLOv8l.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1hZik4LigXQ61JEwUrlYs-d0thd6lkW0l
"""

#IMPORTANT: RUN THIS CELL IN ORDER TO IMPORT YOUR KAGGLE DATA SOURCES,
# THEN FEEL FREE TO DELETE THIS CELL.
# NOTE: THIS NOTEBOOK ENVIRONMENT DIFFERS FROM KAGGLE'S PYTHON
# ENVIRONMENT SO THERE MAY BE MISSING LIBRARIES USED BY YOUR
# NOTEBOOK.
import kagglehub
starsw_intersection_flow_5k_path = kagglehub.dataset_download('starsw/intersection-flow-5k')
base_path = starsw_intersection_flow_5k_path

print('Data source import complete.')

!pip install ultralytics

# Import necessary libraries
import torch
import pandas as pd
import numpy as np
import matplotlib.pyplot as plt
from ultralytics import YOLO
from pathlib import Path
import random
import csv
import os
import kagglehub

# Set seeds
torch.manual_seed(42)
np.random.seed(42)
random.seed(42)

# data.yaml
# Use the dynamically determined path for the dataset
data = f"""
# Dataset paths
train: {base_path}/Intersection-Flow-5K/images/train  # Path to training images
val: {base_path}/Intersection-Flow-5K/images/val     # Path to validation images
test: {base_path}/Intersection-Flow-5K/images/test   # Path to test images

# Class information
nc: 8
names: ['vehicle', 'bus', 'bicycle', 'pedestrian',
        'engine', 'truck', 'tricycle', 'obstacle']
        """
with open('data.yaml', 'w') as file:
    file.write(data)

from ultralytics import YOLO

Final_model = YOLO("yolov8l.pt")

# Training The Final Model
Result_Final_model = Final_model.train(data="data.yaml",
                                       epochs=10,
                                       imgsz = 640,
                                       batch = 16,
                                       lr0=0.01,
                                       dropout= 0.15,
                                       device = 0)

import cv2
import matplotlib.pyplot as plt
import numpy as np

list_of_metrics = ["BoxP_curve.png","BoxR_curve.png","confusion_matrix.png"]
for i in list_of_metrics:
    img = cv2.imread(f"/content/runs/detect/train2/{i}")
    # Check if the image was loaded successfully before attempting to display
    if img is not None:
        # OpenCV reads images in BGR format, matplotlib expects RGB
        img_rgb = cv2.cvtColor(img, cv2.COLOR_BGR2RGB)
        plt.figure(figsize = (16, 12))
        plt.imshow(img_rgb)
        plt.title(i) # Add title for clarity
        plt.axis('off') # Hide axes for image display
        plt.show()
    else:
        print(f"Error: Unable to load image {i}. Check the path and file existence.")

results = pd.read_csv("/content/runs/detect/train2/results.csv")
results.head()

import seaborn as sns

import matplotlib.pyplot as plt

results.columns = results.columns.str.strip()
# Create subplots
fig, axs = plt.subplots(nrows=5, ncols=2, figsize=(15, 15))

# Plot the columns using seaborn
sns.lineplot(x='epoch', y='train/box_loss', data=results, ax=axs[0,0])
sns.lineplot(x='epoch', y='train/cls_loss', data=results, ax=axs[0,1])
sns.lineplot(x='epoch', y='train/dfl_loss', data=results, ax=axs[1,0])
sns.lineplot(x='epoch', y='metrics/precision(B)', data=results, ax=axs[1,1])
sns.lineplot(x='epoch', y='metrics/recall(B)', data=results, ax=axs[2,0])
sns.lineplot(x='epoch', y='metrics/mAP50(B)', data=results, ax=axs[2,1])
sns.lineplot(x='epoch', y='metrics/mAP50-95(B)', data=results, ax=axs[3,0])
sns.lineplot(x='epoch', y='val/box_loss', data=results, ax=axs[3,1])
sns.lineplot(x='epoch', y='val/cls_loss', data=results, ax=axs[4,0])
sns.lineplot(x='epoch', y='val/dfl_loss', data=results, ax=axs[4,1])

# Set titles and axis labels for each subplot
axs[0,0].set(title='Train Box Loss')
axs[0,1].set(title='Train Class Loss')
axs[1,0].set(title='Train DFL Loss')
axs[1,1].set(title='Metrics Precision (B)')
axs[2,0].set(title='Metrics Recall (B)')
axs[2,1].set(title='Metrics mAP50 (B)')
axs[3,0].set(title='Metrics mAP50-95 (B)')
axs[3,1].set(title='Validation Box Loss')
axs[4,0].set(title='Validation Class Loss')
axs[4,1].set(title='Validation DFL Loss')

plt.suptitle('Training Metrics and Loss', fontsize=24)
plt.subplots_adjust(top=0.8)
plt.tight_layout()
plt.show()

# Loading the best performing model
Valid_model = YOLO('/content/runs/detect/train2/weights/best.pt')

# Evaluating the model on the testset
metrics = Valid_model.val(split = 'test')

# final results
print("precision(B): ", metrics.results_dict["metrics/precision(B)"])
print("metrics/recall(B): ", metrics.results_dict["metrics/recall(B)"])
print("metrics/mAP50(B): ", metrics.results_dict["metrics/mAP50(B)"])
print("metrics/mAP50-95(B): ", metrics.results_dict["metrics/mAP50-95(B)"])

"""Visual demonstration of test result predicted by fine-tuned YOLO"""

from PIL import Image
import os

images_path = os.path.join(base_path, "Intersection-Flow-5K/images/test")
images = os.listdir(images_path)
for i in range(5):
    image = os.path.join(images_path, images[i])
    result_predict = Valid_model.predict(source = image, imgsz=(640), iou=0.4)

    # show results
    plot = result_predict[0].plot()
    plot = cv2.cvtColor(plot, cv2.COLOR_BGR2RGB)
    display(Image.fromarray(plot))

